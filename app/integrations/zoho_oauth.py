"""
Zoho OAuth 2.0 endpoints for multi-tenant Zoho CRM integration.

This module handles the OAuth flow for connecting Slack teams to their own Zoho CRM accounts.
Each team's credentials are stored securely in the zoho_installations table.
"""
import logging
import os
import secrets
import base64
from datetime import datetime, timedelta, UTC
from typing import Optional

import requests
from fastapi import APIRouter, Request, HTTPException, Depends
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse
from sqlalchemy.orm import Session

from ..config import config
from ..dependencies import get_db
from ..models import ZohoInstallation, SlackInstallation
from ..utils.encryption import encrypt_token, decrypt_token
from ..templates_zoho import ZOHO_SUCCESS_PAGE_HTML, ZOHO_ERROR_PAGE_HTML

logger = logging.getLogger(__name__)

router = APIRouter()

# Zoho OAuth configuration
ZOHO_CLIENT_ID = os.getenv("ZOHO_CLIENT_ID", "")
ZOHO_CLIENT_SECRET = os.getenv("ZOHO_CLIENT_SECRET", "")
ZOHO_ACCOUNTS_URL = os.getenv("ZOHO_ACCOUNTS_URL", "https://accounts.zoho.com")
ZOHO_API_DOMAIN = os.getenv("ZOHO_API_DOMAIN", "https://www.zohoapis.com")

# Required Zoho scopes
ZOHO_SCOPES = [
    "ZohoCRM.modules.ALL",
    "ZohoCRM.settings.ALL",
    "ZohoCRM.org.READ"
]


# ============================================================================
# STATE CACHE FOR CSRF PROTECTION
# ============================================================================

# In-memory cache for OAuth state nonces
# Format: {nonce: {"team_id": str, "created_at": datetime, "expires_at": datetime}}
_state_cache: dict[str, dict] = {}

# State expiration time (15 minutes)
STATE_EXPIRATION_MINUTES = 15


def _cleanup_expired_states() -> None:
    """Remove expired state entries from cache."""
    now = datetime.now(UTC)
    expired_nonces = [
        nonce for nonce, data in _state_cache.items()
        if data["expires_at"] <= now
    ]
    
    for nonce in expired_nonces:
        del _state_cache[nonce]
    
    if expired_nonces:
        logger.debug(f"Cleaned up {len(expired_nonces)} expired state nonce(s)")


def generate_state(team_id: str) -> str:
    """
    Generate a secure state parameter for OAuth flow with cache-based verification.
    
    The state is stored in an in-memory cache with expiration to enable:
    - CSRF protection (nonce must be generated by our server)
    - Replay attack prevention (nonce used only once)
    - Automatic cleanup of old OAuth flows
    
    Format: base64(team_id:random_nonce)
    
    Args:
        team_id: Slack team ID
        
    Returns:
        Base64-encoded state string
    """
    # Clean up expired states periodically
    _cleanup_expired_states()
    
    # Generate cryptographically secure random nonce
    nonce = secrets.token_urlsafe(16)
    
    # Create state parameter
    state_data = f"{team_id}:{nonce}"
    state = base64.urlsafe_b64encode(state_data.encode()).decode()
    
    # Store nonce in cache with expiration
    now = datetime.now(UTC)
    _state_cache[nonce] = {
        "team_id": team_id,
        "created_at": now,
        "expires_at": now + timedelta(minutes=STATE_EXPIRATION_MINUTES)
    }
    
    logger.debug(f"Generated state for team {team_id}, nonce: {nonce[:8]}..., expires in {STATE_EXPIRATION_MINUTES} min")
    
    return state


def verify_and_consume_state(state: str) -> Optional[str]:
    """
    Verify state parameter and consume the nonce (one-time use).
    
    This function:
    1. Decodes the base64 state parameter
    2. Extracts team_id and nonce
    3. Verifies nonce exists in cache
    4. Checks expiration
    5. Validates team_id matches
    6. Deletes nonce from cache (one-time use)
    
    Args:
        state: Base64-encoded state string from OAuth callback
        
    Returns:
        team_id if state is valid, None otherwise
    """
    try:
        # Decode state parameter
        state_data = base64.urlsafe_b64decode(state.encode()).decode()
        team_id, nonce = state_data.split(":", 1)
        
        # Check if nonce exists in cache
        if nonce not in _state_cache:
            logger.warning(f"Invalid or reused nonce: {nonce[:8]}... (not found in cache)")
            return None
        
        cache_entry = _state_cache[nonce]
        
        # Check expiration
        now = datetime.now(UTC)
        if now > cache_entry["expires_at"]:
            logger.warning(f"Expired nonce: {nonce[:8]}... (created at {cache_entry['created_at']})")
            # Clean up expired entry
            del _state_cache[nonce]
            return None
        
        # Verify team_id matches what was stored
        if cache_entry["team_id"] != team_id:
            logger.error(f"Team ID mismatch! State has '{team_id}' but cache has '{cache_entry['team_id']}'")
            # Don't delete - this could be a tampering attempt
            return None
        
        # Verify successful - delete nonce to prevent reuse
        del _state_cache[nonce]
        
        age_seconds = (now - cache_entry["created_at"]).total_seconds()
        logger.info(f"âœ… State verified for team {team_id}, nonce age: {age_seconds:.1f}s")
        
        return team_id
        
    except ValueError as e:
        logger.error(f"Malformed state parameter: {e}")
        return None
    except Exception as e:
        logger.error(f"Failed to verify state: {e}", exc_info=True)
        return None


def get_cache_stats() -> dict:
    """
    Get statistics about the state cache (for monitoring/debugging).
    
    Returns:
        Dictionary with cache statistics
    """
    now = datetime.now(UTC)
    active = sum(1 for data in _state_cache.values() if data["expires_at"] > now)
    expired = len(_state_cache) - active
    
    return {
        "total_entries": len(_state_cache),
        "active_entries": active,
        "expired_entries": expired,
        "oldest_entry": min(
            (data["created_at"] for data in _state_cache.values()),
            default=None
        )
    }


@router.get("/zoho/install")
async def zoho_install(request: Request, team_id: str):
    """
    Initiate Zoho OAuth flow.
    
    Redirects user to Zoho authorization page.
    The team_id is passed through the OAuth flow via the state parameter.
    
    Query parameters:
        team_id: Slack team ID (required)
        
    Example:
        GET /zoho/install?team_id=T123456
    """
    if not ZOHO_CLIENT_ID or not ZOHO_CLIENT_SECRET:
        logger.error("Zoho OAuth credentials not configured")
        raise HTTPException(
            status_code=500,
            detail="Zoho OAuth is not configured on this server"
        )
    
    if not team_id:
        raise HTTPException(
            status_code=400,
            detail="team_id parameter is required"
        )
    
    # Generate state for CSRF protection
    state = generate_state(team_id)
    
    # Build redirect URI
    redirect_uri = f"{config.APP_BASE_URL}/zoho/install/callback"
    
    # Build Zoho authorization URL
    auth_url = (
        f"{ZOHO_ACCOUNTS_URL}/oauth/v2/auth"
        f"?client_id={ZOHO_CLIENT_ID}"
        f"&response_type=code"
        f"&scope={','.join(ZOHO_SCOPES)}"
        f"&redirect_uri={redirect_uri}"
        f"&state={state}"
        f"&access_type=offline"  # Request refresh token
        f"&prompt=consent"  # Force consent screen to ensure refresh token
    )
    
    logger.info(f"Initiating Zoho OAuth for team {team_id}")
    logger.info(f"Using Redirect URI: {redirect_uri}")
    logger.info(f"Generated Auth URL: {auth_url}")
    return RedirectResponse(url=auth_url)


@router.get("/zoho/install/callback")
async def zoho_install_callback(
    request: Request,
    code: Optional[str] = None,
    state: Optional[str] = None,
    error: Optional[str] = None,
    error_description: Optional[str] = None,
    location: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    Zoho OAuth callback endpoint.
    
    This is called by Zoho after user approves/denies the authorization.
    Exchanges the authorization code for access and refresh tokens, then stores them.
    
    Query parameters (from Zoho):
        code: Authorization code
        state: State parameter (contains team_id)
        error: Error code if authorization failed
        error_description: Human-readable error description
        location: Zoho data center location
    """
    # Handle OAuth errors
    if error:
        logger.error(f"Zoho OAuth error: {error} - {error_description}")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error=error,
                error_description=error_description or "No description provided"
            ),
            status_code=400
        )
    
    # Validate required parameters
    if not code:
        logger.error("No authorization code received")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error="missing_code",
                error_description="No authorization code received from Zoho"
            ),
            status_code=400
        )
    
    if not state:
        logger.error("No state parameter received")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error="missing_state",
                error_description="No state parameter received (CSRF protection)"
            ),
            status_code=400
        )
    
    # Verify and consume state (CSRF protection with cache validation)
    team_id = verify_and_consume_state(state)
    if not team_id:
        logger.error("State verification failed - invalid, expired, or reused nonce")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error="invalid_state",
                error_description="State verification failed. The OAuth flow may have expired or been tampered with. Please try again."
            ),
            status_code=400
        )
    
    # Verify that the team exists in our database
    slack_installation = db.query(SlackInstallation).filter(
        SlackInstallation.team_id == team_id
    ).first()
    
    if not slack_installation:
        logger.error(f"Team {team_id} not found in database")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error="team_not_found",
                error_description=f"Slack team {team_id} is not installed"
            ),
            status_code=404
        )
    
    # Exchange authorization code for tokens
    redirect_uri = f"{config.APP_BASE_URL}/zoho/install/callback"
    
    try:
        logger.info(f"Exchanging code for tokens (team: {team_id})")
        token_response = requests.post(
            f"{ZOHO_ACCOUNTS_URL}/oauth/v2/token",
            data={
                "code": code,
                "client_id": ZOHO_CLIENT_ID,
                "client_secret": ZOHO_CLIENT_SECRET,
                "redirect_uri": redirect_uri,
                "grant_type": "authorization_code"
            },
            timeout=10
        )
        
        if token_response.status_code != 200:
            logger.error(f"Token exchange failed: {token_response.status_code} - {token_response.text}")
            return HTMLResponse(
                content=ZOHO_ERROR_PAGE_HTML.format(
                    error="token_exchange_failed",
                    error_description=f"Failed to exchange code for tokens: {token_response.text}"
                ),
                status_code=500
            )
        
        token_data = token_response.json()
        access_token = token_data.get("access_token")
        refresh_token = token_data.get("refresh_token")
        expires_in = token_data.get("expires_in", 3600)
        
        if not access_token or not refresh_token:
            logger.error(f"Missing tokens in response: {token_data}")
            return HTMLResponse(
                content=ZOHO_ERROR_PAGE_HTML.format(
                    error="incomplete_tokens",
                    error_description="Zoho did not return all required tokens"
                ),
                status_code=500
            )
        
        # Fetch Zoho organization info
        zoho_org_id = None
        zoho_domain = location or "com"  # Default to .com if not provided
        
        try:
            org_response = requests.get(
                f"{ZOHO_API_DOMAIN}/crm/v3/org",
                headers={"Authorization": f"Zoho-oauthtoken {access_token}"},
                timeout=10
            )
            if org_response.status_code == 200:
                org_data = org_response.json()
                if org_data.get("org"):
                    zoho_org_id = org_data["org"][0].get("zgid")
        except Exception as e:
            logger.warning(f"Could not fetch Zoho org info: {e}")
        
        # Encrypt tokens before storage
        encrypted_access_token = encrypt_token(access_token)
        encrypted_refresh_token = encrypt_token(refresh_token)
        
        # Calculate token expiry
        token_expires_at = datetime.now(UTC) + timedelta(seconds=expires_in)
        
        # Store or update installation
        existing = db.query(ZohoInstallation).filter(
            ZohoInstallation.team_id == team_id
        ).first()
        
        if existing:
            # Update existing installation
            logger.info(f"Updating existing Zoho installation for team {team_id}")
            existing.zoho_org_id = zoho_org_id
            existing.zoho_domain = zoho_domain
            existing.access_token = encrypted_access_token
            existing.refresh_token = encrypted_refresh_token
            existing.token_expires_at = token_expires_at
            existing.installed_at = datetime.now(UTC)
        else:
            # Create new installation
            logger.info(f"Creating new Zoho installation for team {team_id}")
            new_installation = ZohoInstallation(
                team_id=team_id,
                zoho_org_id=zoho_org_id,
                zoho_domain=zoho_domain,
                access_token=encrypted_access_token,
                refresh_token=encrypted_refresh_token,
                token_expires_at=token_expires_at,
                installed_at=datetime.now(UTC)
            )
            db.add(new_installation)
        
        db.commit()
        logger.info(f"âœ… Zoho connected successfully for team {team_id}")
        
        # Initialize the Decisions module and fields for this organization
        module_status = "initialized"
        try:
            from .zoho_crm import ZohoCRMClient
            zoho_client = ZohoCRMClient(team_id, db)
            if zoho_client.create_decision_module():
                logger.info(f"âœ… Decisions module initialized for team {team_id}")
                module_status = "initialized"
            else:
                logger.warning(f"âš ï¸ Module creation had issues for team {team_id}")
                module_status = "partial"
        except Exception as e:
            logger.error(f"âŒ Failed to initialize module for team {team_id}: {e}", exc_info=True)
            module_status = "error"
            # Don't fail the entire OAuth - user is already connected
        
        # Redirect to dashboard (instead of showing separate success page)
        # This keeps both integrations on the same dashboard page
        team_name = slack_installation.team_name or team_id
        dashboard_url = f"/dashboard?team_id={team_id}"
        logger.info(f"ðŸ”„ Redirecting to dashboard: {dashboard_url}")
        return RedirectResponse(url=dashboard_url, status_code=302)
        
    except requests.RequestException as e:
        logger.error(f"Request error during token exchange: {e}", exc_info=True)
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error="network_error",
                error_description=f"Network error: {str(e)}"
            ),
            status_code=500
        )
    except Exception as e:
        logger.error(f"Unexpected error in Zoho callback: {e}", exc_info=True)
        db.rollback()
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error="internal_error",
                error_description=f"Internal error: {str(e)}"
            ),
            status_code=500
        )


@router.get("/zoho/status")
async def zoho_status(team_id: str, db: Session = Depends(get_db)):
    """
    Check Zoho connection status for a team.
    
    Query parameters:
        team_id: Slack team ID
        
    Returns:
        JSON with connection status
        
    Example:
        GET /zoho/status?team_id=T123456
    """
    if not team_id:
        raise HTTPException(status_code=400, detail="team_id parameter required")
    
    installation = db.query(ZohoInstallation).filter(
        ZohoInstallation.team_id == team_id
    ).first()
    
    if not installation:
        return JSONResponse(
            content={
                "connected": False,
                "team_id": team_id,
                "message": "Zoho CRM is not connected for this team"
            }
        )
    
    # Check if token is expired or about to expire
    is_expired = False
    if installation.token_expires_at:
        # Handle timezone-naive datetimes from database
        token_expires = installation.token_expires_at
        if token_expires.tzinfo is None:
            # Make it timezone-aware by assuming UTC
            token_expires = token_expires.replace(tzinfo=UTC)
        is_expired = datetime.now(UTC) >= token_expires
    
    return JSONResponse(
        content={
            "connected": True,
            "team_id": team_id,
            "zoho_org_id": installation.zoho_org_id,
            "zoho_domain": installation.zoho_domain,
            "installed_at": installation.installed_at.isoformat(),
            "token_expired": is_expired,
            "token_expires_at": installation.token_expires_at.isoformat() if installation.token_expires_at else None,
            "message": "Zoho CRM is connected"
        }
    )


@router.post("/zoho/disconnect")
async def zoho_disconnect(request: Request, db: Session = Depends(get_db)):
    """
    Disconnect Zoho CRM for a team.
    
    Accepts either:
    - Form data: team_id field
    - JSON body: {"team_id": "T123456"}
    - Query param: ?team_id=T123456
        
    Returns:
        JSON with success/error message or redirect to dashboard
    """
    try:
        # Try to get team_id from multiple sources
        team_id = None
        
        # 1. Try query params first
        team_id = request.query_params.get("team_id")
        
        # 2. Try form data
        if not team_id:
            try:
                form_data = await request.form()
                team_id = form_data.get("team_id")
            except Exception:
                pass
        
        # 3. Try JSON body
        if not team_id:
            try:
                body = await request.body()
                if body:
                    import json
                    data = json.loads(body)
                    team_id = data.get("team_id")
            except Exception:
                pass
        
        if not team_id:
            raise HTTPException(status_code=400, detail="team_id is required")
        
        installation = db.query(ZohoInstallation).filter(
            ZohoInstallation.team_id == team_id
        ).first()
        
        if not installation:
            return JSONResponse(
                content={
                    "success": False,
                    "message": f"No Zoho connection found for team {team_id}"
                },
                status_code=404
            )
        
        # Delete the installation
        db.delete(installation)
        db.commit()
        
        logger.info(f"Zoho disconnected for team {team_id}")
        
        # Check if this was a form submission (browser) or API call
        content_type = request.headers.get("content-type", "")
        accept = request.headers.get("accept", "")
        
        # If it's a form submission, redirect to dashboard
        if "form" in content_type or "text/html" in accept:
            from fastapi.responses import RedirectResponse
            return RedirectResponse(
                url=f"/dashboard?team_id={team_id}",
                status_code=303  # See Other - proper redirect after POST
            )
        
        # Otherwise return JSON
        return JSONResponse(
            content={
                "success": True,
                "message": f"Zoho CRM disconnected for team {team_id}"
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error disconnecting Zoho: {e}", exc_info=True)
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/zoho/cache/stats")
async def zoho_cache_stats():
    """
    Get OAuth state cache statistics (for monitoring/debugging).
    
    Returns:
        JSON with cache statistics including:
        - Total entries
        - Active (non-expired) entries
        - Expired entries waiting for cleanup
        - Age of oldest entry
        
    Example:
        GET /zoho/cache/stats
    """
    stats = get_cache_stats()
    
    # Format oldest_entry as ISO string if it exists
    if stats["oldest_entry"]:
        stats["oldest_entry"] = stats["oldest_entry"].isoformat()
    
    # Add cleanup recommendation
    if stats["expired_entries"] > 10:
        stats["recommendation"] = "High number of expired entries - cleanup will occur on next state generation"
    
    return JSONResponse(content=stats)
