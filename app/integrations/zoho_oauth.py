"""
Zoho OAuth 2.0 endpoints for multi-tenant Zoho CRM integration.

This module handles the OAuth flow for connecting to Zoho CRM.
Zoho is connected FIRST, before Slack. The zoho_org_id is the primary identifier.
Each organization's credentials are stored securely in the zoho_installations table.
"""
import logging
import os
import secrets
import base64
from datetime import datetime, timedelta, UTC
from typing import Optional

import requests
from fastapi import APIRouter, Request, HTTPException, Depends
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse
from sqlalchemy.orm import Session

from ..config import config
from ..dependencies import get_db
from ..models import ZohoInstallation, SlackInstallation
from ..utils.encryption import encrypt_token, decrypt_token
from ..templates_zoho import ZOHO_ERROR_PAGE_HTML

logger = logging.getLogger(__name__)

router = APIRouter()

# Zoho OAuth configuration
ZOHO_CLIENT_ID = os.getenv("ZOHO_CLIENT_ID", "")
ZOHO_CLIENT_SECRET = os.getenv("ZOHO_CLIENT_SECRET", "")
ZOHO_ACCOUNTS_URL = os.getenv("ZOHO_ACCOUNTS_URL", "https://accounts.zoho.com")
ZOHO_API_DOMAIN = os.getenv("ZOHO_API_DOMAIN", "https://www.zohoapis.com")

# Required Zoho scopes
ZOHO_SCOPES = [
    "ZohoCRM.modules.ALL",
    "ZohoCRM.settings.ALL",
    "ZohoCRM.org.READ"
]


# ============================================================================
# STATE CACHE FOR CSRF PROTECTION
# ============================================================================

# In-memory cache for OAuth state nonces
# Format: {nonce: {"created_at": datetime, "expires_at": datetime}}
_state_cache: dict[str, dict] = {}

# State expiration time (15 minutes)
STATE_EXPIRATION_MINUTES = 15


def _cleanup_expired_states() -> None:
    """Remove expired state entries from cache."""
    now = datetime.now(UTC)
    expired_nonces = [
        nonce for nonce, data in _state_cache.items()
        if data["expires_at"] <= now
    ]
    
    for nonce in expired_nonces:
        del _state_cache[nonce]
    
    if expired_nonces:
        logger.debug(f"Cleaned up {len(expired_nonces)} expired state nonce(s)")


def generate_state() -> str:
    """
    Generate a secure state parameter for OAuth flow with cache-based verification.
    
    The state is stored in an in-memory cache with expiration to enable:
    - CSRF protection (nonce must be generated by our server)
    - Replay attack prevention (nonce used only once)
    - Automatic cleanup of old OAuth flows
    
    Returns:
        Base64-encoded state string (nonce)
    """
    # Clean up expired states periodically
    _cleanup_expired_states()
    
    # Generate cryptographically secure random nonce
    nonce = secrets.token_urlsafe(32)
    
    # Create state parameter (just the nonce, no team_id needed for Zoho-first flow)
    state = base64.urlsafe_b64encode(nonce.encode()).decode()
    
    # Store nonce in cache with expiration
    now = datetime.now(UTC)
    _state_cache[nonce] = {
        "created_at": now,
        "expires_at": now + timedelta(minutes=STATE_EXPIRATION_MINUTES)
    }
    
    logger.debug(f"Generated state nonce: {nonce[:8]}..., expires in {STATE_EXPIRATION_MINUTES} min")
    
    return state


def verify_and_consume_state(state: str) -> bool:
    """
    Verify state parameter and consume the nonce (one-time use).
    
    This function:
    1. Decodes the base64 state parameter
    2. Verifies nonce exists in cache
    3. Checks expiration
    4. Deletes nonce from cache (one-time use)
    
    Args:
        state: Base64-encoded state string from OAuth callback
        
    Returns:
        True if state is valid, False otherwise
    """
    try:
        # Decode state parameter
        nonce = base64.urlsafe_b64decode(state.encode()).decode()
        
        # Check if nonce exists in cache
        if nonce not in _state_cache:
            logger.warning(f"Invalid or reused nonce: {nonce[:8]}... (not found in cache)")
            return False
        
        cache_entry = _state_cache[nonce]
        
        # Check expiration
        now = datetime.now(UTC)
        if now > cache_entry["expires_at"]:
            logger.warning(f"Expired nonce: {nonce[:8]}... (created at {cache_entry['created_at']})")
            # Clean up expired entry
            del _state_cache[nonce]
            return False
        
        # Verify successful - delete nonce to prevent reuse
        del _state_cache[nonce]
        
        age_seconds = (now - cache_entry["created_at"]).total_seconds()
        logger.info(f"âœ… State verified, nonce age: {age_seconds:.1f}s")
        
        return True
        
    except ValueError as e:
        logger.error(f"Malformed state parameter: {e}")
        return False
    except Exception as e:
        logger.error(f"Failed to verify state: {e}", exc_info=True)
        return False


def get_cache_stats() -> dict:
    """
    Get statistics about the state cache (for monitoring/debugging).
    
    Returns:
        Dictionary with cache statistics
    """
    now = datetime.now(UTC)
    active = sum(1 for data in _state_cache.values() if data["expires_at"] > now)
    expired = len(_state_cache) - active
    
    return {
        "total_entries": len(_state_cache),
        "active_entries": active,
        "expired_entries": expired,
        "oldest_entry": min(
            (data["created_at"] for data in _state_cache.values()),
            default=None
        )
    }


@router.get("/zoho/install")
async def zoho_install(request: Request):
    """
    Initiate Zoho OAuth flow.
    
    Redirects user to Zoho authorization page.
    This is the FIRST step - Zoho connects before Slack.
    
    Example:
        GET /zoho/install
    """
    if not ZOHO_CLIENT_ID or not ZOHO_CLIENT_SECRET:
        logger.error("Zoho OAuth credentials not configured")
        raise HTTPException(
            status_code=500,
            detail="Zoho OAuth is not configured on this server"
        )
    
    # Generate state for CSRF protection
    state = generate_state()
    
    # Build redirect URI
    redirect_uri = f"{config.APP_BASE_URL}/zoho/install/callback"
    
    # Build Zoho authorization URL
    auth_url = (
        f"{ZOHO_ACCOUNTS_URL}/oauth/v2/auth"
        f"?client_id={ZOHO_CLIENT_ID}"
        f"&response_type=code"
        f"&scope={','.join(ZOHO_SCOPES)}"
        f"&redirect_uri={redirect_uri}"
        f"&state={state}"
        f"&access_type=offline"  # Request refresh token
        f"&prompt=consent"  # Force consent screen to ensure refresh token
    )
    
    logger.info("Initiating Zoho OAuth flow")
    logger.info(f"Using Redirect URI: {redirect_uri}")
    return RedirectResponse(url=auth_url)


@router.get("/zoho/install/callback")
async def zoho_install_callback(
    request: Request,
    code: Optional[str] = None,
    state: Optional[str] = None,
    error: Optional[str] = None,
    error_description: Optional[str] = None,
    location: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    Zoho OAuth callback endpoint.
    
    This is called by Zoho after user approves/denies the authorization.
    Exchanges the authorization code for access and refresh tokens, then stores them.
    
    This is the FIRST step in the connection flow - Zoho connects before Slack.
    After successful connection, redirects to dashboard with org_id.
    
    Query parameters (from Zoho):
        code: Authorization code
        state: State parameter (CSRF protection)
        error: Error code if authorization failed
        error_description: Human-readable error description
        location: Zoho data center location
    """
    # Handle OAuth errors
    if error:
        logger.error(f"Zoho OAuth error: {error} - {error_description}")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message=f"{error}: {error_description or 'No description provided'}",
                retry_url="/dashboard"
            ),
            status_code=400
        )
    
    # Validate required parameters
    if not code:
        logger.error("No authorization code received")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message="No authorization code received from Zoho",
                retry_url="/dashboard"
            ),
            status_code=400
        )
    
    if not state:
        logger.error("No state parameter received")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message="No state parameter received (CSRF protection)",
                retry_url="/dashboard"
            ),
            status_code=400
        )
    
    # Verify and consume state (CSRF protection with cache validation)
    if not verify_and_consume_state(state):
        logger.error("State verification failed - invalid, expired, or reused nonce")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message="State verification failed. The OAuth flow may have expired or been tampered with. Please try again.",
                retry_url="/dashboard"
            ),
            status_code=400
        )
    
    # Exchange authorization code for tokens
    redirect_uri = f"{config.APP_BASE_URL}/zoho/install/callback"
    
    try:
        logger.info("Exchanging code for tokens")
        token_response = requests.post(
            f"{ZOHO_ACCOUNTS_URL}/oauth/v2/token",
            data={
                "code": code,
                "client_id": ZOHO_CLIENT_ID,
                "client_secret": ZOHO_CLIENT_SECRET,
                "redirect_uri": redirect_uri,
                "grant_type": "authorization_code"
            },
            timeout=10
        )
        
        if token_response.status_code != 200:
            logger.error(f"Token exchange failed: {token_response.status_code} - {token_response.text}")
            return HTMLResponse(
                content=ZOHO_ERROR_PAGE_HTML.format(
                    error_message=f"Failed to exchange code for tokens: {token_response.text}",
                    retry_url="/dashboard"
                ),
                status_code=500
            )
        
        token_data = token_response.json()
        access_token = token_data.get("access_token")
        refresh_token = token_data.get("refresh_token")
        expires_in = token_data.get("expires_in", 3600)
        
        if not access_token or not refresh_token:
            logger.error(f"Missing tokens in response: {token_data}")
            return HTMLResponse(
                content=ZOHO_ERROR_PAGE_HTML.format(
                    error_message="Zoho did not return all required tokens",
                    retry_url="/dashboard"
                ),
                status_code=500
            )
        
        # Fetch Zoho organization info - THIS IS REQUIRED for zoho_org_id
        zoho_org_id = None
        zoho_domain = location or "com"  # Default to .com if not provided
        
        try:
            org_response = requests.get(
                f"{ZOHO_API_DOMAIN}/crm/v3/org",
                headers={"Authorization": f"Zoho-oauthtoken {access_token}"},
                timeout=10
            )
            if org_response.status_code == 200:
                org_data = org_response.json()
                if org_data.get("org"):
                    zoho_org_id = org_data["org"][0].get("zgid")
                    logger.info(f"Fetched Zoho organization ID: {zoho_org_id}")
        except Exception as e:
            logger.warning(f"Could not fetch Zoho org info: {e}")
        
        if not zoho_org_id:
            logger.error("Could not fetch Zoho organization ID - this is required")
            return HTMLResponse(
                content=ZOHO_ERROR_PAGE_HTML.format(
                    error_message="Could not fetch Zoho organization ID. Please ensure you have CRM access.",
                    retry_url="/dashboard"
                ),
                status_code=500
            )
        
        # Encrypt tokens before storage
        encrypted_access_token = encrypt_token(access_token)
        encrypted_refresh_token = encrypt_token(refresh_token)
        
        # Calculate token expiry
        token_expires_at = datetime.now(UTC) + timedelta(seconds=expires_in)
        
        # Store or update installation (keyed by zoho_org_id)
        existing = db.query(ZohoInstallation).filter(
            ZohoInstallation.zoho_org_id == zoho_org_id
        ).first()
        
        if existing:
            # Update existing installation
            logger.info(f"Updating existing Zoho installation for org {zoho_org_id}")
            existing.zoho_domain = zoho_domain
            existing.access_token = encrypted_access_token
            existing.refresh_token = encrypted_refresh_token
            existing.token_expires_at = token_expires_at
            existing.installed_at = datetime.now(UTC)
        else:
            # Create new installation
            logger.info(f"Creating new Zoho installation for org {zoho_org_id}")
            new_installation = ZohoInstallation(
                zoho_org_id=zoho_org_id,
                zoho_domain=zoho_domain,
                access_token=encrypted_access_token,
                refresh_token=encrypted_refresh_token,
                token_expires_at=token_expires_at,
                installed_at=datetime.now(UTC)
            )
            db.add(new_installation)
        
        db.commit()
        logger.info(f"âœ… Zoho connected successfully for org {zoho_org_id}")
        
        # Initialize the Decisions module and fields for this organization
        module_status = "initialized"
        try:
            from .zoho_crm import ZohoCRMClient
            zoho_client = ZohoCRMClient(zoho_org_id, db)
            if zoho_client.create_decision_module():
                logger.info(f"âœ… Decisions module initialized for org {zoho_org_id}")
                module_status = "initialized"
            else:
                logger.warning(f"âš ï¸ Module creation had issues for org {zoho_org_id}")
                module_status = "partial"
        except Exception as e:
            logger.error(f"âŒ Failed to initialize module for org {zoho_org_id}: {e}", exc_info=True)
            module_status = "error"
            # Don't fail the entire OAuth - user is already connected
        
        # Redirect to dashboard with org_id
        dashboard_url = f"/dashboard?org_id={zoho_org_id}"
        logger.info(f"ðŸ”„ Redirecting to dashboard: {dashboard_url}")
        return RedirectResponse(url=dashboard_url, status_code=302)
        
    except requests.RequestException as e:
        logger.error(f"Request error during token exchange: {e}", exc_info=True)
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message=f"Network error: {str(e)}",
                retry_url="/dashboard"
            ),
            status_code=500
        )
    except Exception as e:
        logger.error(f"Unexpected error in Zoho callback: {e}", exc_info=True)
        db.rollback()
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message=f"Internal error: {str(e)}",
                retry_url="/dashboard"
            ),
            status_code=500
        )


@router.get("/zoho/status")
async def zoho_status(org_id: str, db: Session = Depends(get_db)):
    """
    Check Zoho connection status for an organization.
    
    Query parameters:
        org_id: Zoho organization ID
        
    Returns:
        JSON with connection status
        
    Example:
        GET /zoho/status?org_id=123456789
    """
    if not org_id:
        raise HTTPException(status_code=400, detail="org_id parameter required")
    
    installation = db.query(ZohoInstallation).filter(
        ZohoInstallation.zoho_org_id == org_id
    ).first()
    
    if not installation:
        return JSONResponse(
            content={
                "connected": False,
                "org_id": org_id,
                "message": "Zoho CRM is not connected for this organization"
            }
        )
    
    # Check if token is expired or about to expire
    is_expired = False
    if installation.token_expires_at:
        # Handle timezone-naive datetimes from database
        token_expires = installation.token_expires_at
        if token_expires.tzinfo is None:
            # Make it timezone-aware by assuming UTC
            token_expires = token_expires.replace(tzinfo=UTC)
        is_expired = datetime.now(UTC) >= token_expires
    
    # Check if Slack is connected
    slack_install = db.query(SlackInstallation).filter(
        SlackInstallation.zoho_org_id == org_id
    ).first()
    
    return JSONResponse(
        content={
            "connected": True,
            "org_id": org_id,
            "zoho_domain": installation.zoho_domain,
            "installed_at": installation.installed_at.isoformat(),
            "token_expired": is_expired,
            "token_expires_at": installation.token_expires_at.isoformat() if installation.token_expires_at else None,
            "slack_connected": slack_install is not None,
            "slack_team_id": slack_install.team_id if slack_install else None,
            "slack_team_name": slack_install.team_name if slack_install else None,
            "message": "Zoho CRM is connected"
        }
    )


@router.post("/zoho/disconnect")
async def zoho_disconnect(request: Request, db: Session = Depends(get_db)):
    """
    Disconnect Zoho CRM for an organization.
    
    WARNING: This will also delete the linked Slack installation due to cascade.
    
    Accepts either:
    - Form data: org_id field
    - JSON body: {"org_id": "123456789"}
    - Query param: ?org_id=123456789
        
    Returns:
        JSON with success/error message or redirect to dashboard
    """
    try:
        # Try to get org_id from multiple sources
        org_id = None
        
        # 1. Try query params first
        org_id = request.query_params.get("org_id")
        
        # 2. Try form data
        if not org_id:
            try:
                form_data = await request.form()
                org_id = form_data.get("org_id")
            except Exception:
                pass
        
        # 3. Try JSON body
        if not org_id:
            try:
                body = await request.body()
                if body:
                    import json
                    data = json.loads(body)
                    org_id = data.get("org_id")
            except Exception:
                pass
        
        if not org_id:
            raise HTTPException(status_code=400, detail="org_id is required")
        
        installation = db.query(ZohoInstallation).filter(
            ZohoInstallation.zoho_org_id == org_id
        ).first()
        
        if not installation:
            return JSONResponse(
                content={
                    "success": False,
                    "message": f"No Zoho connection found for org {org_id}"
                },
                status_code=404
            )
        
        # Delete the installation (cascades to Slack and related data)
        db.delete(installation)
        db.commit()
        
        logger.info(f"Zoho disconnected for org {org_id}")
        
        # Check if this was a form submission (browser) or API call
        content_type = request.headers.get("content-type", "")
        accept = request.headers.get("accept", "")
        
        # If it's a form submission, redirect to dashboard (fresh start)
        if "form" in content_type or "text/html" in accept:
            from fastapi.responses import RedirectResponse
            return RedirectResponse(
                url="/dashboard",
                status_code=303  # See Other - proper redirect after POST
            )
        
        # Otherwise return JSON
        return JSONResponse(
            content={
                "success": True,
                "message": f"Zoho CRM disconnected for org {org_id}"
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error disconnecting Zoho: {e}", exc_info=True)
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/zoho/cache/stats")
async def zoho_cache_stats():
    """
    Get OAuth state cache statistics (for monitoring/debugging).
    
    Returns:
        JSON with cache statistics including:
        - Total entries
        - Active (non-expired) entries
        - Expired entries waiting for cleanup
        - Age of oldest entry
        
    Example:
        GET /zoho/cache/stats
    """
    stats = get_cache_stats()
    
    # Format oldest_entry as ISO string if it exists
    if stats["oldest_entry"]:
        stats["oldest_entry"] = stats["oldest_entry"].isoformat()
    
    # Add cleanup recommendation
    if stats["expired_entries"] > 10:
        stats["recommendation"] = "High number of expired entries - cleanup will occur on next state generation"
    
    return JSONResponse(content=stats)
