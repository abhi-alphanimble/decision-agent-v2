"""
Zoho OAuth 2.0 endpoints for multi-tenant Zoho CRM integration.

This module handles the OAuth flow for connecting to Zoho CRM.
Zoho is connected FIRST, before Slack. The zoho_org_id is the primary identifier.
Each organization's credentials are stored securely in the zoho_installations table.
"""
import logging
import os
import secrets
import base64
from datetime import datetime, timedelta, UTC
from typing import Optional

import requests
from fastapi import APIRouter, Request, HTTPException, Depends
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse
from sqlalchemy.orm import Session

from ..config import config
from ..dependencies import get_db
from ..models import ZohoInstallation, SlackInstallation
from ..utils.encryption import encrypt_token, decrypt_token
from ..templates_zoho import ZOHO_ERROR_PAGE_HTML, ZOHO_OAUTH_SUCCESS_HTML

logger = logging.getLogger(__name__)

router = APIRouter()

# Zoho OAuth configuration
ZOHO_CLIENT_ID = os.getenv("ZOHO_CLIENT_ID", "")
ZOHO_CLIENT_SECRET = os.getenv("ZOHO_CLIENT_SECRET", "")
ZOHO_ACCOUNTS_URL = os.getenv("ZOHO_ACCOUNTS_URL", "https://accounts.zoho.com")
ZOHO_API_DOMAIN = os.getenv("ZOHO_API_DOMAIN", "https://www.zohoapis.com")

# Required Zoho scopes
ZOHO_SCOPES = [
    "ZohoCRM.modules.ALL",
    "ZohoCRM.settings.ALL",
    "ZohoCRM.org.READ"
]


# ============================================================================
# STATE CACHE FOR CSRF PROTECTION
# ============================================================================

# In-memory cache for OAuth state nonces
# Format: {nonce: {"created_at": datetime, "expires_at": datetime}}
_state_cache: dict[str, dict] = {}

# State expiration time (15 minutes)
STATE_EXPIRATION_MINUTES = 15


def _cleanup_expired_states() -> None:
    """Remove expired state entries from cache."""
    now = datetime.now(UTC)
    expired_nonces = [
        nonce for nonce, data in _state_cache.items()
        if data["expires_at"] <= now
    ]
    
    for nonce in expired_nonces:
        del _state_cache[nonce]
    
    if expired_nonces:
        logger.debug(f"Cleaned up {len(expired_nonces)} expired state nonce(s)")


def generate_state(expected_org_id: Optional[str] = None) -> str:
    """
    Generate a secure state parameter for OAuth flow with cache-based verification.
    
    The state is stored in an in-memory cache with expiration to enable:
    - CSRF protection (nonce must be generated by our server)
    - Replay attack prevention (nonce used only once)
    - Automatic cleanup of old OAuth flows
    - Org ID validation (optional)
    
    Args:
        expected_org_id: Optional Zoho org ID that we expect the OAuth to return.
                        Used to validate the user selects the correct organization.
    
    Returns:
        Base64-encoded state string (nonce)
    """
    # Clean up expired states periodically
    _cleanup_expired_states()
    
    # Generate cryptographically secure random nonce
    nonce = secrets.token_urlsafe(32)
    
    # Create state parameter (just the nonce, no team_id needed for Zoho-first flow)
    state = base64.urlsafe_b64encode(nonce.encode()).decode()
    
    # Store nonce in cache with expiration
    now = datetime.now(UTC)
    _state_cache[nonce] = {
        "created_at": now,
        "expires_at": now + timedelta(minutes=STATE_EXPIRATION_MINUTES),
        "expected_org_id": expected_org_id  # Store for validation after OAuth
    }
    
    logger.debug(f"Generated state nonce: {nonce[:8]}..., expected_org_id: {expected_org_id}, expires in {STATE_EXPIRATION_MINUTES} min")
    
    return state


def verify_and_consume_state(state: str) -> tuple[bool, Optional[str]]:
    """
    Verify state parameter and consume the nonce (one-time use).
    
    This function:
    1. Decodes the base64 state parameter
    2. Verifies nonce exists in cache
    3. Checks expiration
    4. Deletes nonce from cache (one-time use)
    5. Returns the expected_org_id if one was stored
    
    Args:
        state: Base64-encoded state string from OAuth callback
        
    Returns:
        Tuple of (is_valid, expected_org_id)
        - is_valid: True if state is valid, False otherwise
        - expected_org_id: The org ID that was expected (if provided during state generation)
    """
    try:
        # Decode state parameter
        nonce = base64.urlsafe_b64decode(state.encode()).decode()
        
        # Check if nonce exists in cache
        if nonce not in _state_cache:
            logger.warning(f"Invalid or reused nonce: {nonce[:8]}... (not found in cache)")
            return (False, None)
        
        cache_entry = _state_cache[nonce]
        
        # Check expiration
        now = datetime.now(UTC)
        if now > cache_entry["expires_at"]:
            logger.warning(f"Expired nonce: {nonce[:8]}... (created at {cache_entry['created_at']})")
            # Clean up expired entry
            del _state_cache[nonce]
            return (False, None)
        
        # Get expected_org_id before deleting
        expected_org_id = cache_entry.get("expected_org_id")
        
        # Verify successful - delete nonce to prevent reuse
        del _state_cache[nonce]
        
        age_seconds = (now - cache_entry["created_at"]).total_seconds()
        logger.info(f"âœ… State verified, nonce age: {age_seconds:.1f}s, expected_org_id: {expected_org_id}")
        
        return (True, expected_org_id)
        
    except ValueError as e:
        logger.error(f"Malformed state parameter: {e}")
        return (False, None)
    except Exception as e:
        logger.error(f"Failed to verify state: {e}", exc_info=True)
        return (False, None)


def get_cache_stats() -> dict:
    """
    Get statistics about the state cache (for monitoring/debugging).
    
    Returns:
        Dictionary with cache statistics
    """
    now = datetime.now(UTC)
    active = sum(1 for data in _state_cache.values() if data["expires_at"] > now)
    expired = len(_state_cache) - active
    
    return {
        "total_entries": len(_state_cache),
        "active_entries": active,
        "expired_entries": expired,
        "oldest_entry": min(
            (data["created_at"] for data in _state_cache.values()),
            default=None
        )
    }


@router.get("/zoho/install")
async def zoho_install(request: Request, expected_org_id: Optional[str] = None):
    """
    Initiate Zoho OAuth flow.
    
    Redirects user to Zoho authorization page.
    This is the FIRST step - Zoho connects before Slack.
    
    Query parameters:
        expected_org_id: Optional. The org ID from the WebTab where the connection
                        is being initiated. Used to validate the correct org is connected.
    
    Example:
        GET /zoho/install
        GET /zoho/install?expected_org_id=909975127
    """
    if not ZOHO_CLIENT_ID or not ZOHO_CLIENT_SECRET:
        logger.error("Zoho OAuth credentials not configured")
        raise HTTPException(
            status_code=500,
            detail="Zoho OAuth is not configured on this server"
        )
    
    # Generate state for CSRF protection, including expected_org_id for validation
    state = generate_state(expected_org_id=expected_org_id)
    
    if expected_org_id:
        logger.info(f"Initiating Zoho OAuth flow with expected_org_id: {expected_org_id}")
    else:
        logger.info("Initiating Zoho OAuth flow (no expected_org_id provided)")
    
    # Build redirect URI
    redirect_uri = f"{config.APP_BASE_URL}/zoho/install/callback"
    
    # Build Zoho authorization URL
    auth_url = (
        f"{ZOHO_ACCOUNTS_URL}/oauth/v2/auth"
        f"?client_id={ZOHO_CLIENT_ID}"
        f"&response_type=code"
        f"&scope={','.join(ZOHO_SCOPES)}"
        f"&redirect_uri={redirect_uri}"
        f"&state={state}"
        f"&access_type=offline"  # Request refresh token
        f"&prompt=consent"  # Force consent screen to ensure refresh token
    )
    
    logger.info(f"Using Redirect URI: {redirect_uri}")
    return RedirectResponse(url=auth_url)


@router.get("/zoho/install/callback")
async def zoho_install_callback(
    request: Request,
    code: Optional[str] = None,
    state: Optional[str] = None,
    error: Optional[str] = None,
    error_description: Optional[str] = None,
    location: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    Zoho OAuth callback endpoint.
    
    This is called by Zoho after user approves/denies the authorization.
    Exchanges the authorization code for access and refresh tokens, then stores them.
    
    This is the FIRST step in the connection flow - Zoho connects before Slack.
    After successful connection, redirects to dashboard with org_id.
    
    Query parameters (from Zoho):
        code: Authorization code
        state: State parameter (CSRF protection)
        error: Error code if authorization failed
        error_description: Human-readable error description
        location: Zoho data center location
        accounts-server: The accounts server URL where the code should be exchanged
    """
    # Get accounts-server from query params (it has a hyphen so we get it from request)
    accounts_server = request.query_params.get("accounts-server")
    
    # Handle OAuth errors
    if error:
        logger.error(f"Zoho OAuth error: {error} - {error_description}")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message=f"{error}: {error_description or 'No description provided'}",
                retry_url="/dashboard"
            ),
            status_code=400
        )
    
    # Validate required parameters
    if not code:
        logger.error("No authorization code received")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message="No authorization code received from Zoho",
                retry_url="/dashboard"
            ),
            status_code=400
        )
    
    if not state:
        logger.error("No state parameter received")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message="No state parameter received (CSRF protection)",
                retry_url="/dashboard"
            ),
            status_code=400
        )
    
    # Verify and consume state (CSRF protection with cache validation)
    is_valid, expected_org_id = verify_and_consume_state(state)
    if not is_valid:
        logger.error("State verification failed - invalid, expired, or reused nonce")
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message="State verification failed. The OAuth flow may have expired or been tampered with. Please try again.",
                retry_url="/dashboard"
            ),
            status_code=400
        )
    
    logger.info(f"State verified, expected_org_id: {expected_org_id}")
    
    # Exchange authorization code for tokens
    redirect_uri = f"{config.APP_BASE_URL}/zoho/install/callback"
    
    # Use the accounts-server from callback if available (ensures correct data center)
    # This is critical - the code must be exchanged at the same DC where it was issued
    token_exchange_url = accounts_server if accounts_server else ZOHO_ACCOUNTS_URL
    
    try:
        logger.info(f"Exchanging code for tokens at: {token_exchange_url}")
        token_response = requests.post(
            f"{token_exchange_url}/oauth/v2/token",
            data={
                "code": code,
                "client_id": ZOHO_CLIENT_ID,
                "client_secret": ZOHO_CLIENT_SECRET,
                "redirect_uri": redirect_uri,
                "grant_type": "authorization_code"
            },
            timeout=10
        )
        
        if token_response.status_code != 200:
            logger.error(f"Token exchange failed: {token_response.status_code} - {token_response.text}")
            return HTMLResponse(
                content=ZOHO_ERROR_PAGE_HTML.format(
                    error_message=f"Failed to exchange code for tokens: {token_response.text}",
                    retry_url="/dashboard"
                ),
                status_code=500
            )
        
        token_data = token_response.json()
        access_token = token_data.get("access_token")
        refresh_token = token_data.get("refresh_token")
        expires_in = token_data.get("expires_in", 3600)
        
        if not access_token or not refresh_token:
            logger.error(f"Missing tokens in response: {token_data}")
            return HTMLResponse(
                content=ZOHO_ERROR_PAGE_HTML.format(
                    error_message="Zoho did not return all required tokens",
                    retry_url="/dashboard"
                ),
                status_code=500
            )
        
        # Fetch Zoho organization info - THIS IS REQUIRED for zoho_org_id
        zoho_org_id = None
        zoho_domain = location or "com"  # Default to .com if not provided
        
        # Map location to the correct API domain (must match where user's org is hosted)
        API_DOMAINS = {
            "us": "https://www.zohoapis.com",
            "in": "https://www.zohoapis.in",
            "eu": "https://www.zohoapis.eu",
            "au": "https://www.zohoapis.com.au",
            "cn": "https://www.zohoapis.com.cn",
            "jp": "https://www.zohoapis.jp",
            "ca": "https://www.zohoapis.ca",
        }
        api_domain = API_DOMAINS.get(location, ZOHO_API_DOMAIN)
        logger.info(f"Using API domain: {api_domain} (location: {location})")
        
        try:
            org_response = requests.get(
                f"{api_domain}/crm/v3/org",
                headers={"Authorization": f"Zoho-oauthtoken {access_token}"},
                timeout=10
            )
            logger.info(f"Org API response status: {org_response.status_code}")
            if org_response.status_code == 200:
                org_data = org_response.json()
                if org_data.get("org"):
                    zoho_org_id = org_data["org"][0].get("zgid")
                    logger.info(f"Fetched Zoho organization ID: {zoho_org_id}")
            else:
                logger.error(f"Org API error: {org_response.status_code} - {org_response.text}")
        except Exception as e:
            logger.warning(f"Could not fetch Zoho org info: {e}")
        
        if not zoho_org_id:
            logger.error("Could not fetch Zoho organization ID - this is required")
            return HTMLResponse(
                content=ZOHO_ERROR_PAGE_HTML.format(
                    error_message="Could not fetch Zoho organization ID. Please ensure you have CRM access.",
                    retry_url="/dashboard"
                ),
                status_code=500
            )
        
        # Log org ID comparison (warning only, don't block - sandbox IDs differ from production)
        if expected_org_id and str(zoho_org_id) != str(expected_org_id):
            logger.warning(
                f"Org ID mismatch (may be sandbox vs production): "
                f"Expected: {expected_org_id}, Got: {zoho_org_id}. "
                f"Proceeding with connection using org_id from OAuth: {zoho_org_id}"
            )
        else:
            logger.info(f"Org ID matches or no validation required: {zoho_org_id}")
        
        # Encrypt tokens before storage
        encrypted_access_token = encrypt_token(access_token)
        encrypted_refresh_token = encrypt_token(refresh_token)
        
        # Calculate token expiry
        token_expires_at = datetime.now(UTC) + timedelta(seconds=expires_in)
        
        # Store or update installation (keyed by zoho_org_id)
        existing = db.query(ZohoInstallation).filter(
            ZohoInstallation.zoho_org_id == zoho_org_id
        ).first()
        
        if existing:
            # Update existing installation
            logger.info(f"Updating existing Zoho installation for org {zoho_org_id}")
            existing.zoho_domain = zoho_domain
            existing.access_token = encrypted_access_token
            existing.refresh_token = encrypted_refresh_token
            existing.token_expires_at = token_expires_at
            existing.installed_at = datetime.now(UTC)
        else:
            # Create new installation
            logger.info(f"Creating new Zoho installation for org {zoho_org_id}")
            new_installation = ZohoInstallation(
                zoho_org_id=zoho_org_id,
                zoho_domain=zoho_domain,
                access_token=encrypted_access_token,
                refresh_token=encrypted_refresh_token,
                token_expires_at=token_expires_at,
                installed_at=datetime.now(UTC)
            )
            db.add(new_installation)
        
        db.commit()
        logger.info(f"âœ… Zoho connected successfully for org {zoho_org_id}")
        
        # Initialize the Decisions module and fields for this organization
        module_status = "initialized"
        try:
            from .zoho_crm import ZohoCRMClient
            zoho_client = ZohoCRMClient(zoho_org_id, db)
            if zoho_client.create_decision_module():
                logger.info(f"âœ… Decisions module initialized for org {zoho_org_id}")
                module_status = "initialized"
            else:
                logger.warning(f"âš ï¸ Module creation had issues for org {zoho_org_id}")
                module_status = "partial"
        except Exception as e:
            logger.error(f"âŒ Failed to initialize module for org {zoho_org_id}: {e}", exc_info=True)
            module_status = "error"
            # Don't fail the entire OAuth - user is already connected
        
        # Return success page that closes popup and signals parent to refresh
        logger.info(f"ðŸ”„ Showing success page for org {zoho_org_id}")
        return HTMLResponse(
            content=ZOHO_OAUTH_SUCCESS_HTML.format(
                service_name="Zoho CRM",
                service_type="zoho",
                org_id=zoho_org_id
            ),
            status_code=200
        )
        
    except requests.RequestException as e:
        logger.error(f"Request error during token exchange: {e}", exc_info=True)
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message=f"Network error: {str(e)}",
                retry_url="/dashboard"
            ),
            status_code=500
        )
    except Exception as e:
        logger.error(f"Unexpected error in Zoho callback: {e}", exc_info=True)
        db.rollback()
        return HTMLResponse(
            content=ZOHO_ERROR_PAGE_HTML.format(
                error_message=f"Internal error: {str(e)}",
                retry_url="/dashboard"
            ),
            status_code=500
        )


@router.get("/zoho/status")
async def zoho_status(org_id: str, db: Session = Depends(get_db)):
    """
    Check Zoho connection status for an organization.
    
    Query parameters:
        org_id: Zoho organization ID
        
    Returns:
        JSON with connection status
        
    Example:
        GET /zoho/status?org_id=123456789
    """
    if not org_id:
        raise HTTPException(status_code=400, detail="org_id parameter required")
    
    installation = db.query(ZohoInstallation).filter(
        ZohoInstallation.zoho_org_id == org_id
    ).first()
    
    if not installation:
        return JSONResponse(
            content={
                "connected": False,
                "org_id": org_id,
                "message": "Zoho CRM is not connected for this organization"
            }
        )
    
    # Check if token is expired or about to expire
    is_expired = False
    if installation.token_expires_at:
        # Handle timezone-naive datetimes from database
        token_expires = installation.token_expires_at
        if token_expires.tzinfo is None:
            # Make it timezone-aware by assuming UTC
            token_expires = token_expires.replace(tzinfo=UTC)
        is_expired = datetime.now(UTC) >= token_expires
    
    # Check if Slack is connected
    slack_install = db.query(SlackInstallation).filter(
        SlackInstallation.zoho_org_id == org_id
    ).first()
    
    return JSONResponse(
        content={
            "connected": True,
            "org_id": org_id,
            "zoho_domain": installation.zoho_domain,
            "installed_at": installation.installed_at.isoformat(),
            "token_expired": is_expired,
            "token_expires_at": installation.token_expires_at.isoformat() if installation.token_expires_at else None,
            "slack_connected": slack_install is not None,
            "slack_team_id": slack_install.team_id if slack_install else None,
            "slack_team_name": slack_install.team_name if slack_install else None,
            "message": "Zoho CRM is connected"
        }
    )


def revoke_zoho_token(refresh_token_encrypted: str, accounts_url: str = ZOHO_ACCOUNTS_URL) -> bool:
    """Revoke Zoho CRM tokens."""
    try:
        # Decrypt refresh token
        refresh_token = decrypt_token(refresh_token_encrypted)
        if not refresh_token:
            return False

        # Zoho's revocation expects the token to be revoked (refresh token is best to revoke entire session)
        response = requests.post(
            f"{accounts_url}/oauth/v2/token/revoke",
            params={"token": refresh_token},
            timeout=10
        )
        if response.status_code == 200:
            logger.info("Zoho CRM tokens revoked successfully")
            return True
        else:
            logger.warning(f"Failed to revoke Zoho tokens: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        logger.error(f"Error revoking Zoho tokens: {e}")
        return False


@router.api_route("/zoho/disconnect", methods=["GET", "POST"])
async def zoho_disconnect(request: Request, db: Session = Depends(get_db)):
    """
    Disconnect Zoho CRM for an organization.
    
    WARNING: This will also delete the linked Slack installation and revoke tokens for both services.
    
    Accepts:
    - Query param: ?org_id=123456789
    - Form data: org_id field (POST)
    - JSON body: {"org_id": "123456789"} (POST)
    """
    try:
        # Try to get org_id from multiple sources
        org_id = None
        
        # 1. Try query params first (works for GET and POST)
        org_id = request.query_params.get("org_id")
        
        # 2. Try form data or JSON body for POST requests
        if not org_id and request.method == "POST":
            try:
                content_type = request.headers.get("content-type", "")
                if "application/json" in content_type:
                    data = await request.json()
                    org_id = data.get("org_id")
                else:
                    form_data = await request.form()
                    org_id = form_data.get("org_id")
            except Exception:
                pass
        
        if not org_id:
            logger.warning("Zoho disconnect requested without org_id")
            return RedirectResponse(url="/dashboard", status_code=303)
        
        installation = db.query(ZohoInstallation).filter(
            ZohoInstallation.zoho_org_id == org_id
        ).first()
        
        if not installation:
            logger.warning(f"No Zoho installation found for org {org_id}")
            return RedirectResponse(url="/dashboard", status_code=303)

        # 1. Revoke Slack tokens first if connected
        slack_install = db.query(SlackInstallation).filter(
            SlackInstallation.zoho_org_id == org_id
        ).first()
        if slack_install:
            try:
                from ..slack.client import get_client_for_team
                client = get_client_for_team(slack_install.team_id, db)
                if client:
                    client.revoke_token()
            except Exception as e:
                logger.warning(f"Failed to revoke Slack token during Zoho disconnect: {e}")

        # 2. Revoke Zoho tokens
        if installation.refresh_token:
            revoke_zoho_token(installation.refresh_token)
        
        # 3. Delete the installation (cascades to related data in DB)
        db.delete(installation)
        db.commit()
        
        logger.info(f"âœ… Zoho and Slack disconnected for org {org_id}")
        
        # Always redirect to dashboard for success
        return RedirectResponse(
            url="/dashboard",
            status_code=303
        )
        
    except Exception as e:
        logger.error(f"Error disconnecting Zoho: {e}", exc_info=True)
        db.rollback()
        # Still redirect but maybe with an error (though 500 is safer for debugging)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/zoho/cache/stats")
async def zoho_cache_stats():
    """
    Get OAuth state cache statistics (for monitoring/debugging).
    
    Returns:
        JSON with cache statistics including:
        - Total entries
        - Active (non-expired) entries
        - Expired entries waiting for cleanup
        - Age of oldest entry
        
    Example:
        GET /zoho/cache/stats
    """
    stats = get_cache_stats()
    
    # Format oldest_entry as ISO string if it exists
    if stats["oldest_entry"]:
        stats["oldest_entry"] = stats["oldest_entry"].isoformat()
    
    # Add cleanup recommendation
    if stats["expired_entries"] > 10:
        stats["recommendation"] = "High number of expired entries - cleanup will occur on next state generation"
    
    return JSONResponse(content=stats)
